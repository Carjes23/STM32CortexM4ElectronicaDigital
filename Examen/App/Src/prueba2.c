/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "PLLDriver.h"
#include <stdint.h>
#include <stdio.h>
#include "PLLDriver.h"
//#include "FreeRTOS.h"
//#include "task.h"



#define STACK_SIZE 200;

void vTaskOne(void *pvParameters);
void vTaskTwo(void *pvParameters);
void configPeripherals(void);
void taskCreation(void);

GPIO_Handler_t ledUsuario;

//Handler para el control de la terminal
USART_Handler_t handlerTerminal = { 0 };

/*DefiniciÃ³n de variables del sistema*/

uint8_t globalCounter = 0;
uint32_t SystemCoreClock = 16E6;
uint8_t rxData = 0;
char msg[8] = { 0 };

int main(void) {
	configPeripherals();
//	taskCreation();
	//Start the created task running.
//	vTaskStartScheduler();

	/* Loop forever */
	while (1) {
		/* SI llegamos es que algo salio mal... */
	}
}

void configPeripherals(void) {

	//Activacion cooprocesador matematico(importante para esta tarea)
	SCB->CPACR |= (0xF << 20);

	configPLL(100);

	ledUsuario.pGPIOx = GPIOA;
	ledUsuario.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_OUT;
	ledUsuario.GPIO_PinConfig_t.GPIO_PinNumber = PIN_5;
	GPIO_Config(&ledUsuario);

	handlerTerminal.ptrUSARTx = USART2;
	handlerTerminal.USART_Config.USART_baudrate = 115200;
	handlerTerminal.USART_Config.USART_datasize = USART_DATASIZE_8BIT;
	handlerTerminal.USART_Config.USART_mode = USART_MODE_RXTX;
	handlerTerminal.USART_Config.USART_parity = USART_PARITY_NONE;
	handlerTerminal.USART_Config.USART_stopbits = USART_STOPBIT_1;
	handlerTerminal.USART_Config.USART_RX_Int_Ena = ENABLE;

	USART_Config(&handlerTerminal);

	writeChar(&handlerTerminal, 23);
}

//void taskCreation(void) {
//	BaseType_t xReturned;
//	TaskHandle_t HandleTask1 = NULL;
//	TaskHandle_t HandleTask2 = NULL;
//
//	xReturned = xTaskCreate(vTaskOne, /* Function that implements the task. */
//	"Task-1", /* Text name for the task. */
//	512, /* Stack size in words, not bytes. */
//	NULL, /* Parameter passed into the task. */
//	2,/* Priority at which the task is created. */
//	&HandleTask1); /* Used to pass out the created task's handle. */
//
//	configASSERT(xReturned == pdPASS);
//
//	xReturned = xTaskCreate(vTaskTwo, /* Function that implements the task. */
//	"Task-2", /* Text name for the task. */
//	512, /* Stack size in words, not bytes. */
//	NULL, /* Parameter passed into the task. */
//	2,/* Priority at which the task is created. */
//	&HandleTask2); /* Used to pass out the created task's handle. */
//
//	configASSERT(xReturned == pdPASS);
//
//}
//
///* Fncin que gobierna la tarea 1 */
//void vTaskOne(void *pvParameters) {
//
//	while (1) {
//		printf("toggle\n");
//		GPIOxTooglePin(&ledUsuario);
//		vTaskDelay(pdMS_TO_TICKS(250));
//	}
//}
//
///* Fncin que gobierna la tarea 2 */
//void vTaskTwo(void *pvParameters) {
//
//	while (1) {
//
//		printf("tarea2\n");
//
//	}
//}

void USART2Rx_Callback(void) {
	rxData = getRxData();
	writeChar(&handlerTerminal, rxData);
}

